# instructions from https://docs.hsr.io/hsrc_user_manual_en/howto/pc_install.html
 
# ... (removed b/c includes non-public info)
sudo apt-get update
sudo apt-get install ros-noetic-tmc-desktop-full

# Uninstall 
$ sudo apt-get purge ros-noetic-hsr* ros-noetic-tmc-*
$ sudo rm /etc/apt/sources.list.d/tmc.list*
$ sudo apt-get update
$ sudo apt-key del tmc.key


# Test that gazebo is working:
roslaunch gazebo_ros empty_world.launch


# Update `ros_configs/`:
cp /opt/ros/noetic/share/hsrb_gazebo_launch/launch/hsrb_butler_bot_world.launch ros_configs/
cp /opt/ros/noetic/share/hsrb_gazebo_launch/launch/include/hsrb_gazebo_common.xml ros_configs/
cp /opt/ros/noetic/share/tmc_gazebo_worlds/worlds/butler_bot_world.world ros_configs/




# Rviz
rostopic echo /clicked_point # then 'Publish Point' in Rviz




# -----------
# Get collision avoidance working

curr_x, curr_y = omni_base.get_pose()[0].x, omni_base.get_pose()[0].y
def reset(curr_x, curr_y):
    collision_world.remove_all()
    whole_body.move_to_neutral()
    omni_base.go_abs(curr_x, curr_y, 0)

def add_box(curr_x, curr_y):
    collision_world.add_box(x=0.5, y=0.75, z=.7, pose=geometry.pose(x=curr_x + 1.0, y=curr_y, z=0.35), frame_id='map')
    whole_body.collision_world = collision_world

collision_pose=geometry.Pose(
    pos=geometry.vector3(x=curr_x+1.0, y=curr_y, z=0.5), ori=geometry.quaternion(x=0.7071068, y=0, z=0.7071068, w=0))
non_collision_pose=geometry.Pose(
    pos=geometry.vector3(x=curr_x+1.0, y=curr_y, z=0.8), ori=geometry.quaternion(x=0.7071068, y=0, z=0.7071068, w=0))

#
reset(curr_x, curr_y)
add_box(curr_x, curr_y)
whole_body.move_end_effector_pose(pose=non_collision_pose, ref_frame_id="map")
whole_body.move_end_effector_pose(pose=collision_pose, ref_frame_id="map")

reset(curr_x, curr_y)
add_box(curr_x, curr_y)
whole_body.move_end_effector_pose(pose=non_collision_pose, ref_frame_id="map")
# Didn't work - collides into box
whole_body.move_end_effector_pose(pose=collision_pose, ref_frame_id="map")
# start state in collision

reset(curr_x, curr_y)
add_box(curr_x, curr_y)
whole_body.move_end_effector_pose(pose=non_collision_pose, ref_frame_id="map")
# succcess, now avoids
reset(curr_x, curr_y)


# Note: A success sequence was move_to(non_colliding) and let finish all the way (it waits for a while then moves again)


# test if in bad state
reset(curr_x, curr_y)
add_box(curr_x, curr_y)
whole_body.move_end_effector_pose(pose=non_collision_pose, ref_frame_id="map")

whole_body.move_end_effector_pose(pose=collision_pose, ref_frame_id="map")





# -----------
# Tutorial

collision_world.add_box(x=0.3, y=0.3, z=0.3, pose=geometry.pose(x=1.0, z=0.15), frame_id='map')
whole_body.move_to_neutral()
whole_body.move_end_effector_pose(geometry.pose(z=1.3), 'hand_palm_link')
# Collides, check


whole_body.move_to_neutral()
whole_body.collision_world = collision_world
omni_base.go_abs(0,0,0)
whole_body.move_end_effector_pose(geometry.pose(z=1.5), 'hand_palm_link')


# -----------
# Test grasping

ihsrb

def reset():
    omni_base.go_abs(0,0,0)
    whole_body.move_to_neutral()
    collision_world.remove_all()
reset()

collision_world.add_box(x=0.5, y=0.75, z=.7, pose=geometry.pose(x=1.0, y=0.0, z=0.35), frame_id='map') # desk height is .7
whole_body.collision_world = collision_world

non_colliding_target_pose=geometry.Pose(pos=geometry.vector3(x=0.5, y=0.0, z=0.8), ori=geometry.quaternion(x=0.7071, y=0, z=0.7071, w=0))
whole_body.move_end_effector_pose(pose=non_colliding_target_pose, ref_frame_id="map")

target_pose=geometry.Pose(pos=geometry.vector3(x=1.0, y=0.0, z=0.8), ori=geometry.quaternion(x=0.7071, y=0, z=0.7071, w=0))
whole_body.move_end_effector_pose(pose=target_pose, ref_frame_id="map")




whole_body.collision_world = None
whole_body.collision_world = collision_world

# -----------
# Investigate joint changing when it shouldn't

import numpy as np
np.set_printoptions(suppress=True)

whole_body.move_to_neutral()


whole_body.move_to_joint_positions({
            'arm_lift_joint': 0.0,
            'arm_flex_joint': 0.0,
            'arm_roll_joint': 0.0,
            'wrist_flex_joint': -1.57,
            'wrist_roll_joint': 0.0,
            'head_pan_joint': 0.0,
            'head_tilt_joint': 0.0,
        })

old_posv = np.array(whole_body.joint_state.position)
whole_body.move_to_joint_positions(
    {'arm_lift_joint': 0.2, 'arm_flex_joint': 0.0, 'arm_roll_joint': 0.0})
whole_body.move_to_joint_positions({'arm_lift_joint': 0.2})
new_posv = np.array(whole_body.joint_state.position)

def print_diffs(old, new):
    names = whole_body.joint_state.name
    for i in range(len(old)):
        if abs(old[i] - new[i]) > 0.003:
            print(f'{names[i]}: {round(old[i], 4)} -> {round(new[i],4)}')

new_posv = np.array(whole_body.joint_state.position)
print_diffs(old_posv, new_posv)

# -----------
# Test hand forward motion


# Bug: This will cause the end effector to rotate by its current map->hand_palm_link rotation, which we don't want
# whole_body.move_end_effector_pose(
#     geometry.Pose(pos=geometry.vector3(x=0, y=0, z=0.05), ori=whole_body.get_end_effector_pose().ori), ref_frame_id="hand_palm_link")

# This results in a slight rotation about the maps +z axis, why?? so annoying
whole_body.move_end_effector_pose(
    geometry.Pose(pos=geometry.vector3(x=0, y=0, z=0.05), ori=geometry.quaternion()), ref_frame_id="hand_palm_link")
whole_body.move_end_effector_pose(geometry.pose(z=0.1), ref_frame_id='hand_palm_link')

# This is the same as above
whole_body.move_end_effector_by_line((0, 0, 1), 0.3)



# -----------
# Development

# 1. Start gazebo
# roslaunch hsrb_gazebo_launch hsrb_megaweb2015_world.launch
# roslaunch hsrb_gazebo_launch hsrb_apartment_world.launch
roslaunch hsrb_gazebo_launch hsrb_butler_bot_world.launch
# Then press play on gazebo


# 2. Run python 
cdbb
python3 main.py


sim_mode
ihsrb

